{"pages":[{"url":"http://www.instantinate.com/pages/about_nate.html","text":"What kind of guy names a blog \"Instanti-nate\" anyway? Well you wanted to know so here goes. Born. Eats. Sleeps. Works. Ta-da!","tags":"Pages","loc":"http://www.instantinate.com/pages/about_nate.html","title":"About Nate"},{"url":"http://www.instantinate.com/python/a_basic_python_function.html","text":"What do dictionaries and baking cakes have in common? Read below to find out. First we'll load in some data below. This is a list of dictionaries that contains information about different movies. #Loading in a movie ratings data set. movies = [ { \"name\" : \"Usual Suspects\" , \"imdb\" : 7.0 , \"category\" : \"Thriller\" }, { \"name\" : \"Hitman\" , \"imdb\" : 6.3 , \"category\" : \"Action\" }, { \"name\" : \"Dark Knight\" , \"imdb\" : 9.0 , \"category\" : \"Adventure\" }, { \"name\" : \"The Help\" , \"imdb\" : 8.0 , \"category\" : \"Drama\" }, { \"name\" : \"The Choice\" , \"imdb\" : 6.2 , \"category\" : \"Romance\" }, { \"name\" : \"Colonia\" , \"imdb\" : 7.4 , \"category\" : \"Romance\" }, { \"name\" : \"Love\" , \"imdb\" : 6.0 , \"category\" : \"Romance\" }, { \"name\" : \"Bride Wars\" , \"imdb\" : 5.4 , \"category\" : \"Romance\" }, { \"name\" : \"AlphaJet\" , \"imdb\" : 3.2 , \"category\" : \"War\" }, { \"name\" : \"Ringing Crime\" , \"imdb\" : 4.0 , \"category\" : \"Crime\" }, { \"name\" : \"Joking muck\" , \"imdb\" : 7.2 , \"category\" : \"Comedy\" }, { \"name\" : \"What is the name\" , \"imdb\" : 9.2 , \"category\" : \"Suspense\" }, { \"name\" : \"Detective\" , \"imdb\" : 7.0 , \"category\" : \"Suspense\" }, { \"name\" : \"Exam\" , \"imdb\" : 4.2 , \"category\" : \"Thriller\" }, { \"name\" : \"We Two\" , \"imdb\" : 7.2 , \"category\" : \"Romance\" } ] It starts with a def Every function needs a definition. Think of it like a normal dictionary. If you were to go look up a certain word you would need to know the first few letters to find it. But there also would only be one possible definition for that word in the dictionary. Python functions are the same in this regard, they need a unique name so that you can find it later. We're going to definie our function below: def genre_avg ( cat ): Wait a minute?! What's that \"cat\" thing in there?!?! (Your ingredients) That is a scary thing called a \"parameter\". It is basically the ingredients to your recipe. If you want to bake a cake you put ingredients into it and out comes a delicious cake. For parameters you \"pass\" these ingredients and then tell the function what to do with them and hopefully [crossesfingers] we get cake. Create an empty list. (Get out a mixing bowl) The genre_avg list will hold all the results of our function. def genre_avg ( cat ): genre_avg = [] For Loop or not to For Loop (Meaasure the ingredients) We have the ingredients and the mixing bowl... so now we need to measure the ingredients. The for loop in this function goes through each statement in the dictionary above and measures it against the \"parameter\" we passed it. In this case we're interested only in movies that fall in the Action genre. So we measure out all the action movies from our dataset and then what? Can you see what happens next? def genre_avg ( cat ): genre_avg = [] for x in movies : if cat == x [ \"category\" ]: Append (Mix the ingredients) This takes all the ingredients (parameters) that you just measured and mixes them together. And where do you mix things? In the mixing bowl of course! So now all our ingredients have been measured and are back in our mixing bowl all neat and unbaked... hmm... I wonder what the next step is. def genre_avg ( cat ): genre_avg = [] for x in movies : if cat == x [ \"category\" ]: genre_avg . append ( x [ 'imdb' ]) Return (Bake it!!!!) Now we bake all those nice ingredients to get the most perfect cake we ever could ask for. In this case, a perfect average of score of a particular genre in our movie dataset. def genre_avg ( cat ): genre_avg = [] for x in movies : if cat == x [ \"category\" ]: genre_avg . append ( x [ 'imdb' ]) return sum ( genre_avg ) / len ( genre_avg ) Now for the magic. This is not just any cake baking exercise. This is a magical cake machine that can give you any kind of cake you want so long as you give it the ingredients with the right \"parameter\". That's what is going on in the last statement after the function is defined. We reference that function and give it some ingredients and instantly we have some magic cake! How about that. genre_avg ( \"Action\" ) def genre_avg ( cat ): genre_avg = [] for x in movies : if cat == x [ \"category\" ]: genre_avg . append ( x [ 'imdb' ]) return sum ( genre_avg ) / len ( genre_avg ) genre_avg ( \"Action\" ) 6.3","tags":"python","loc":"http://www.instantinate.com/python/a_basic_python_function.html","title":"A Basic Python Function"},{"url":"http://www.instantinate.com/articles/billboard_analysis.html","text":"Here is some open ended analysis using pandas to show the power of this library for handling literally anything that can be thrown at it. import pandas as pd import numpy as np import matplotlib.pyplot as plt % matplotlib inline Pandas to read in data data = pd . read_csv ( '../data/billboard.csv' ) df = pd . DataFrame ( data ) df . head () year artist.inverted track time genre date.entered date.peaked x1st.week x2nd.week x3rd.week ... x67th.week x68th.week x69th.week x70th.week x71st.week x72nd.week x73rd.week x74th.week x75th.week x76th.week 0 2000 Destiny's Child Independent Women Part I 3:38 Rock 2000-09-23 2000-11-18 78 63.0 49.0 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 1 2000 Santana Maria, Maria 4:18 Rock 2000-02-12 2000-04-08 15 8.0 6.0 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 2 2000 Savage Garden I Knew I Loved You 4:07 Rock 1999-10-23 2000-01-29 71 48.0 43.0 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 3 2000 Madonna Music 3:45 Rock 2000-08-12 2000-09-16 41 23.0 18.0 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 4 2000 Aguilera, Christina Come On Over Baby (All I Want Is You) 3:38 Rock 2000-08-05 2000-10-14 57 47.0 45.0 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 5 rows × 83 columns Renaming column names df . columns = [ col . replace ( '.week' , '' ) for col in df . columns ] df . columns = [ col . replace ( 'x' , '' ) for col in df . columns ] df . columns = [ col . replace ( 'st' , '' ) for col in df . columns ] df . columns = [ col . replace ( 'nd' , '' ) for col in df . columns ] df . columns = [ col . replace ( 'rd' , '' ) for col in df . columns ] df . columns = [ col . replace ( 'th' , '' ) for col in df . columns ] #df.columns = ufo.columns.str.replace(' ', '_') Describe your data: check the value counts + descrisptive stats #We will first drop 'year' since all the songs are from 2000 df . drop ( 'year' , axis = 1 , inplace = True ) #basic describe df . describe () 1 2 3 4 5 6 7 8 9 10 ... 67 68 69 70 71 72 73 74 75 76 count 317.000000 312.000000 307.000000 300.000000 292.000000 280.000000 269.000000 260.000000 253.000000 244.000000 ... 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 mean 79.958991 71.173077 65.045603 59.763333 56.339041 52.360714 49.219331 47.119231 46.343874 45.786885 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN std 14.686865 18.200443 20.752302 22.324619 23.780022 24.473273 25.654279 26.370782 27.136419 28.152357 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN min 15.000000 8.000000 6.000000 5.000000 2.000000 1.000000 1.000000 1.000000 1.000000 1.000000 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 25% 74.000000 NaN NaN NaN NaN NaN NaN NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 50% 81.000000 NaN NaN NaN NaN NaN NaN NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 75% 91.000000 NaN NaN NaN NaN NaN NaN NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN max 100.000000 100.000000 100.000000 100.000000 100.000000 99.000000 100.000000 99.000000 100.000000 100.000000 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 8 rows × 76 columns df2 = pd . melt ( df , id_vars = [ 'arti.inverted' , 'track' , 'time' , 'genre' , 'date.entered' , 'date.peaked' ], var_name = 'week' , value_name = 'rank' ) #checking function that was run print df2 . shape print df2 . columns (24092, 8) Index([u'arti.inverted', u'track', u'time', u'genre', u'date.entered', u'date.peaked', u'week', u'rank'], dtype='object') #We now the data formated to plot ranking over time for each track. #We will use other methods to determine which tracks to plot. df3 = df2 [ df2 [ 'track' ] == 'I Wanna Know' ] plt . plot ( df3 [ 'rank' ]) plt . ylabel ( 'Weekly Rank' ) plt . axis ([ 0 , 18000 , 100 , 0 ]) plt . show () Future Exploratory options... the world is yours with pandas. Look at time it takes to get to the top. (time entered, to time peak) Also add a column called time in top 100. Compare the three columns. That was interesting... now lets wrangle this dataset for some cool correlations. Data wrangling for the most correlated genres #create a new dataframe for manipulation. df7 = df2 Group the data df7 = df7 . groupby ([ 'week' , 'genre' ], as_index = False ) . mean () #check that the group by function worked. df7 . head () week genre rank 0 1 Country 82.405405 1 1 Electronica 84.500000 2 1 Gospel 76.000000 3 1 Jazz 89.000000 4 1 Latin 73.222222 Create a pivot table #Use the pivot table function to get to something that can be correlated. df7 = df7 . pivot ( index = 'week' , columns = 'genre' , values = 'rank' ) #Moving the week column from the index back into a column position on the data table. df7 . reset_index ( inplace = True ) df7 . head ( 5 ) genre week Country Electronica Gospel Jazz Latin Pop R&B Rap Reggae Rock 0 1 82.405405 84.500000 76.0 89.0 73.222222 79.222222 84.086957 85.172414 72.0 76.116788 1 10 52.377049 55.750000 59.0 NaN 43.250000 43.571429 63.866667 53.380952 75.0 35.895238 2 11 51.016949 53.250000 66.0 NaN 49.625000 50.142857 62.538462 52.538462 84.0 36.048077 3 12 50.714286 59.750000 68.0 NaN 35.285714 58.250000 67.000000 50.000000 92.0 33.734694 4 13 52.301887 49.333333 61.0 NaN 39.285714 58.333333 59.666667 53.235294 85.0 34.125000 #Sorting the data inside week after it is converted to a string. df7 [ 'week' ] = df7 . week . astype ( int ) df7 . sort ( 'week' ) df7 . head () /anaconda/lib/python2.7/site-packages/ipykernel/__main__.py:3: FutureWarning: sort(columns=....) is deprecated, use sort_values(by=.....) app.launch_new_instance() genre week Country Electronica Gospel Jazz Latin Pop R&B Rap Reggae Rock 0 1 82.405405 84.500000 76.0 89.0 73.222222 79.222222 84.086957 85.172414 72.0 76.116788 1 10 52.377049 55.750000 59.0 NaN 43.250000 43.571429 63.866667 53.380952 75.0 35.895238 2 11 51.016949 53.250000 66.0 NaN 49.625000 50.142857 62.538462 52.538462 84.0 36.048077 3 12 50.714286 59.750000 68.0 NaN 35.285714 58.250000 67.000000 50.000000 92.0 33.734694 4 13 52.301887 49.333333 61.0 NaN 39.285714 58.333333 59.666667 53.235294 85.0 34.125000 #Remove the pesky column and index names that will mess up the correlation formula later. df7 . index . name = None df7 . columns . name = None #Remove the week column since we sorted by it already. df7 . drop ( 'week' , inplace = True , axis = 1 ) df7 . head () Country Electronica Gospel Jazz Latin Pop R&B Rap Reggae Rock 0 82.405405 84.500000 76.0 89.0 73.222222 79.222222 84.086957 85.172414 72.0 76.116788 1 52.377049 55.750000 59.0 NaN 43.250000 43.571429 63.866667 53.380952 75.0 35.895238 2 51.016949 53.250000 66.0 NaN 49.625000 50.142857 62.538462 52.538462 84.0 36.048077 3 50.714286 59.750000 68.0 NaN 35.285714 58.250000 67.000000 50.000000 92.0 33.734694 4 52.301887 49.333333 61.0 NaN 39.285714 58.333333 59.666667 53.235294 85.0 34.125000 Data wrangling for the most correlated artist rankings df8 = df2 Group the data df8 = df8 . groupby ([ 'week' , 'arti.inverted' ], as_index = False ) . mean () df8 . shape (17328, 3) df8 = df8 [ np . isfinite ( df8 [ 'rank' ])] df8 . shape (3989, 3) counts = df8 [ 'arti.inverted' ] . value_counts () ##Removing any artists that have less than 15 datapoints on the rankings. df8 = df8 [ df8 [ 'arti.inverted' ] . isin ( counts [ counts > 30 ] . index )] Create a pivot table df8 = df8 . pivot ( index = 'week' , columns = 'arti.inverted' , values = 'rank' ) #Moving the week column from the index back into a column position on the data table. df8 . reset_index ( inplace = True ) #Sorting the data inside week after it is converted to a string. df8 [ 'week' ] = df8 . week . astype ( int ) df8 . sort ( 'week' ) df8 . head () /anaconda/lib/python2.7/site-packages/ipykernel/__main__.py:3: FutureWarning: sort(columns=....) is deprecated, use sort_values(by=.....) app.launch_new_instance() arti.inverted week 3 Doors Down Aaliyah Anthony, Marc BBMak Braxton, Toni Creed Destiny's Child Hill, Faith Joe Jordan, Montell Lonestar Nelly Pink Savage Garden Vertical Horizon matchbox twenty 0 1 78.5 71.5 79.5 99.0 79.0 82.5 78.333333 82.0 85.5 92.0 82.666667 100.0 55.0 73.0 67.0 60.0 1 10 56.0 23.0 44.5 18.0 21.0 65.5 12.333333 49.0 53.0 24.0 33.333333 36.0 11.5 16.5 22.5 12.0 2 11 56.0 23.0 43.0 19.0 27.0 63.5 10.333333 42.0 52.5 24.0 33.000000 37.0 10.0 19.0 20.0 8.0 3 12 55.0 22.5 43.5 15.0 29.0 68.0 7.666667 46.0 54.5 20.0 31.666667 30.0 11.0 22.5 19.0 6.0 4 13 54.0 22.0 50.0 18.0 32.0 70.5 2.666667 55.5 54.0 19.0 35.000000 23.0 12.0 25.0 19.0 1.0 #Remove the pesky column and index names that will mess up the correlation formula later. df8 . index . name = None df8 . columns . name = None #Remove the week column since we sorted by it already. df8 . drop ( 'week' , inplace = True , axis = 1 ) Data wrangling for the most correlated song rankings How would you do this part? #df9 = df2 Run a correlation function on the dataframes from the wrangling steps. This is a simple formula that I have been working to improve to work on any data set. It is designed to be a useful alternative to the spray and pray sns.pairplot or scatter matrix methods. sns.pairplot (on df7) = 14s corrr_pairs function (on df7) =384ms def corr_pairs ( df_input , coef_percentile ): #,mse_percentile #from sklearn.metrics import mean_squared_error #Get top correlated pairs using Pearson coefficient c = df_input . corr () s = c . unstack () so = s . sort_values ( kind = \"quicksort\" ) df_output = pd . DataFrame ( so . abs (), columns = [ 'coef' ]) df_output = df_output . reset_index () df_output . drop_duplicates ( 'coef' , inplace = True ) df_output . dropna ( inplace = True ) #df_input = df_input.fillna(0.0) #Get mean squared error for better accuracy #mse_l = [] #for i in range(len(df_output.iloc[:,0:2])): #mse_var = mean_squared_error(df_input[df_output.iloc[i,0]], df_input[df_output.iloc[i,1]]) #mse_l.append(mse_var) #df_output['mse'] = mse_l #Filter the results by both Coefficient and MSE for best pairs. df_output = df_output [( df_output [ 'coef' ] < 1 ) & ( df_output . coef > np . percentile ( df_output [ 'coef' ], coef_percentile ))] #& (df_output.mse < np.percentile(df_output['mse'],mse_percentile))] #Plot the best pairs. for i in range ( len ( df_output . iloc [:, 0 : 2 ])): colors = [ 'r' , 'b' ] plt . scatter ( df_output . iloc [ i , 0 ], df_output . iloc [ i , 1 ], data = df_input , c = colors ) plt . xlabel ( df_output . iloc [ i , 0 ]) plt . ylabel ( df_output . iloc [ i , 1 ]) plt . legend () plt . show () return df_output Showing the most correlated genres in the rankings corr_pairs ( df7 , 95 ) level_0 level_1 coef 86 Electronica Country 0.848179 88 Electronica R&B 0.913870 Showing the most correlated artists in the rankings corr_pairs ( df8 , 95 ) level_0 level_1 coef 230 Creed Joe 0.909992 232 Savage Garden Aaliyah 0.949246 234 BBMak matchbox twenty 0.954013 236 matchbox twenty Destiny's Child 0.965130 238 Destiny's Child BBMak 0.982112 Showing the most correlated songs in the rankings How would you do this part?","tags":"Articles","loc":"http://www.instantinate.com/articles/billboard_analysis.html","title":"Billboard Analysis"},{"url":"http://www.instantinate.com/python/load_dataset_with_csv_reader.html","text":"Quick reference for using built in python functionality to import a csv dataset. import csv Brings in the csv library that is core to python. with open('../data/sales/data.csv', 'rU') as f: Declare open to be used. Specify the file location. Select a dialect to use. Assign the results to the variable f. data = [ ] Create an empty list to receive the data from the f variable. reader = csv.reader(f) Create a reader variable for the csv reader to be applied to the f variable. for row in reader: Create a for loop to iterate over each row of the f variable(csv) using the reader variable. data.append(row) Append rows to the data list as they are read with the reader variable print data Print your data set as a list of lists with the first list being the header row of the csv file. import csv with open ( '../data/sales_data.csv' , 'rU' ) as f : data = [] reader = csv . reader ( f ) for row in reader : data . append ( row ) print data #f.close() -- each with statement has a close statement built into the block so this is not needed. [['volume_sold', '2015_margin', '2015_q1_sales', '2016_q1_sales'], ['18.4207604861', '93.8022814583', '337166.53', '337804.05'], ['4.77650991918', '21.0824246877', '22351.86', '21736.63'], ['16.6024006077', '93.6124943024', '277764.46', '306942.27'], ['4.29611149826', '16.8247038328', '16805.11', '9307.75'], ['8.15602328201', '35.0114570034', '54411.42', '58939.9'], ['5.00512242518', '31.8774372328', '255939.81', '332979.03'], ['14.60675', '76.5189730216', '319020.69', '302592.88'], ['4.45646649485', '19.3373453608', '45340.33', '55315.23'], ['5.04752965097', '26.142470349', '57849.23', '42398.57'], ['5.38807023767', '22.4270237673', '51031.04', '56241.57'], ['9.34734863474', '41.892132964', '68657.91', '3536.14'], ['10.9303977273', '66.4030492424', '4151.93', '137416.93'], ['6.27020860495', '47.8693242069', '121837.56', '158476.55'], ['12.3959191176', '86.7601504011', '146725.31', '125731.51'], ['4.55771189614', '22.9481762576', '119287.76', '21834.49'], ['4.20012242627', '18.7060545353', '20335.03', '39609.55'], ['10.2528698945', '44.0411766297', '110552.94', '204038.87'], ['12.0767847594', '62.1990040107', '204237.78', '15689.8'], ['3.7250952381', '14.2518095238', '16939.15', '48545.69'], ['3.21072662722', '16.0432686391', '55498.12', '16320.74'], ['6.29097142857', '25.1911714286', '15983.98', '53182.55'], ['7.43482131661', '31.7530658307', '71758.66', '30402.43'], ['4.37622478386', '23.1614514016', '62988.17', '47217.4'], ['12.9889127838', '48.8207407407', '29637.75', '6367.76'], ['11.6974557522', '73.2315044248', '48759.71', '329252.09'], ['5.96517512509', '23.4503335716', '89736.7', '332976.05'], ['3.94522273425', '14.1447926267', '5577.61', '234926.02'], ['7.36958530901', '36.4085284899', '310035.66', '151934.45'], ['7.34350882699', '36.1718619066', '310718.21', '314068.92'], ['12.3500273544', '59.8934779211', '258284.84', '61847.52'], ['8.41791967737', '37.1085548647', '150049.71', '203644.27'], ['10.2608361718', '52.4055916932', '309568.16', '123632.78'], ['7.82435369972', '30.681099171', '66468.32', '1050711.75'], ['10.3314300532', '48.1333683392', '321983.24', '149791.31'], ['12.5284878049', '47.7406803594', '115531.13', '61560.7'], ['18.7447505256', '97.2243398739', '926706.76', '260966.41'], ['6.65773264189', '31.2923926822', '157981.2', '160278.07'], ['10.6321289355', '35.27017991', '51078.36', '78108.56'], ['6.92770422965', '31.9091555963', '272703.74', '253886.88'], ['6.61817422161', '29.1482532051', '180760.93', '173395.13'], ['7.12444444444', '32.6235916667', '72185.66', '91524.76'], ['9.84966032435', '47.9893704508', '263161.4', '247802.36'], ['11.5058377559', '55.5221865049', '164809.62', '115591.86'], ['6.30981315215', '31.941637952', '60986.22', '233350.35'], ['10.1866219839', '49.3420628537', '210690.45', '84940.69'], ['10.1221793301', '42.8693852124', '139068.33', '115993.15'], ['10.8003469032', '53.1849073341', '209403.19', '125207.35'], ['7.26782845188', '25.4050062762', '75110.03', '161300.14'], ['10.6737166742', '43.9390962494', '123291.57', '164939.85'], ['9.15026865672', '44.5348318408', '157591.18', '147632.84'], ['8.12418187744', '39.530065189', '163684.93', '168603.49'], ['6.27579970306', '31.5106033203', '146850.63', '342772.02'], ['10.6772953319', '50.1331972789', '143950.01', '102829.3'], ['5.88898828541', '28.7115801384', '136167.32', '216415.08'], ['10.6401714545', '52.4235630748', '327172.32', '174492.82'], ['4.75559643255', '24.0028010033', '105869.94', '41213.34'], ['10.246884068', '47.3184344342', '176266.68', '91213.98'], ['10.29268081', '49.1944300868', '176720.07', '256707.1'], ['4.41819548872', '19.9170827068', '44836.7', '75866.02'], ['7.10134734573', '32.71362436', '65830.25', '50434.54'], ['8.00611901938', '36.2773863187', '228680.53', '141712.31'], ['7.79050337838', '35.2223614865', '73810.68', '91203.94'], ['11.1293822598', '40.0093030623', '54655.98', '156730.02'], ['9.34847653987', '45.5890982815', '156056.28', '24206.67'], ['6.31088643791', '28.2592197712', '80923.05', '218335.21'], ['11.6256060606', '55.1925378788', '167606.75', '325127.17'], ['6.65440717629', '29.106349454', '25575.88', '94229.41'], ['7.93041476808', '39.1116473887', '211902.95', '117784.92'], ['9.003562316', '46.7565544652', '312502.67', '166847.54'], ['14.4394353772', '57.2886237318', '85217.68', '73117.79'], ['11.0115404852', '46.2992604502', '89525.66', '100545.74'], ['5.72389564186', '25.5950192707', '176252.03', '68966.63'], ['7.77732012195', '36.7157591463', '68258.49', '96059.65'], ['4.75918372602', '20.0006463242', '88008.31', '211600.93'], ['7.78586691659', '29.0692439863', '67219.54', '234774.87'], ['5.03499140759', '22.7097016091', '100722.77', '268226.7'], ['11.6845098446', '58.9404393782', '147242.83', '58122.85'], ['5.14772910448', '25.7666753731', '227702.34', '106662.37'], ['10.0860303763', '49.1620319871', '286763.37', '147781.41'], ['7.94465682362', '33.9956304868', '59531.82', '67514.95'], ['5.29439978635', '24.4766550941', '122811.86', '170466.11'], ['11.8265363003', '52.3184580805', '156513.07', '94158.15'], ['6.300925868', '30.5095964967', '55538.11', '139676.38'], ['8.64269487751', '36.2843302577', '143498.37', '167692.5'], ['6.04822838631', '30.1712350678', '84998.58', '180371.58'], ['9.47492913676', '41.0171194552', '138010.02', '298889.32'], ['3.99185767098', '20.0513661569', '146424.29', '133868.58'], ['8.59207381371', '45.5986531395', '175475.49', '39138.81'], ['7.21148957299', '35.8870443261', '247716.78', '343447.68'], ['8.19108557079', '37.9469113386', '130512.99', '191091.14'], ['7.69531160115', '29.3906663471', '52054.1', '184729.87'], ['13.6351500118', '64.7439062131', '332692.67', '37179.58'], ['6.96681681682', '35.0125088725', '135418.28', '40160.26'], ['11.2323237697', '52.2156089683', '163104.8', '40970.96'], ['5.09546375267', '22.4304264392', '45612.45', '135871.39'], ['11.9368836649', '49.1816335142', '56995.82', '92843.04'], ['5.90627376426', '25.0323193916', '39867.38', '295483.47'], ['9.12709469154', '45.8722118604', '133081.37', '130377.49'], ['7.7544572697', '34.7604217536', '108362.38', '192747.83'], ['7.58599675412', '39.9868794518', '271021.94', '103958.63'], ['7.43725207583', '34.6033448222', '134589.33', '106452.13'], ['9.8798900768', '41.6839918687', '216171.01', '12380.85'], ['9.30319388778', '40.8443061122', '104354.49', '94010.77'], ['9.21365050557', '44.7063598652', '105046.24', '51773.27'], ['5.18177205308', '21.1562997658', '13677.13', '242057.36'], ['8.55507774799', '41.547077748', '89053.08', '392226.28'], ['5.78126590331', '24.6607061069', '51427.05', '369424.59'], ['8.0710230118', '40.1006629307', '264408.55', '73141.35'], ['10.1250032713', '50.3450808487', '294990.21', '292690.86'], ['11.0196516733', '51.4318879891', '358098.75', '172189.31'], ['8.17666774927', '32.3875251705', '68077.3', '211032.4'], ['9.42171292239', '53.4813935145', '313345.86', '171119.44'], ['4.85870921867', '24.5552275389', '163324.44', '201433.01'], ['9.31378525791', '43.8089558984', '203099.8', '200599.95'], ['8.30018036767', '43.4441935484', '104044.33', '476439.16'], ['6.50688776965', '33.4178523235', '202835.96', '215106.77'], ['9.5852099677', '44.3454176281', '192934.41', '204808.54'], ['12.45572275', '65.5244131168', '447305.5', '37858.67'], ['8.09288312646', '39.7529703822', '205170.43', '382790.84'], ['8.68651837806', '46.2175087515', '201282.29', '58332.41'], ['8.34731752963', '32.7325389894', '36855.39', '2443253.18'], ['9.29224055739', '49.786953612', '381036.91', '209066.17'], ['9.77711182109', '44.9972396166', '46509.65', '137697.56'], ['29.878030039', '168.245861698', '2337324.42', '129489.89'], ['8.78393692369', '49.313768542', '208389.88', '72810.95'], ['11.9757685161', '56.569739846', '145742.16', '158368.58'], ['11.1401021385', '47.8089690393', '187407.93', '153305.98'], ['7.5605488194', '30.9038417358', '62335.59', '289199.43'], ['7.39098798637', '37.2649829658', '138878.63', '241311.79'], ['6.43360588592', '35.850617415', '169131.81', '343060.63'], ['13.7999774485', '68.1836227448', '280506.28', '128500.31'], ['6.44703955254', '34.2461556133', '223641.14', '79554.12'], ['8.01794477751', '46.0017090264', '361865.13', '191155.87'], ['6.2553554256', '26.9316699155', '134325.62', '111207.97'], ['9.69742181905', '48.3078228694', '145361.36', '83399.61'], ['7.77268351232', '36.216199621', '185580.5', '25290.33'], ['8.75192030725', '37.1569323092', '93901.53', '20962.08'], ['6.79288937945', '33.5548344371', '68438.51', '15307.3'], ['7.68249438202', '33.223011236', '32698.19', '10464.02'], ['4.38545511613', '20.8197112367', '22829.66', '52246.46'], ['3.60671020408', '15.8903673469', '13141.2', '75566.37'], ['8.45364705882', '35.4949411765', '8738.45', '103585.1'], ['5.21488185976', '26.0287842988', '48441.46', '276396.86'], ['8.40056149733', '37.0314331551', '87115.74', '305851.47'], ['6.84136327817', '29.1820981087', '102794.01', '260453.94'], ['12.5099672623', '72.4642572637', '306947.29', '30441.76'], ['9.0148700565', '52.1879774011', '225615.38', '10564.6'], ['7.20036424796', '40.9748793849', '327334.28', '19357.49'], ['5.77809677419', '23.8230645161', '27114.29', '613414.14'], ['4.94129392971', '24.1203833866', '7539.14', '63793.71'], ['6.00045070423', '26.6531361502', '20378.73', '78706.47'], ['11.9971174753', '65.067257829', '501953.12', '22675.76'], ['10.6377691184', '51.4916463712', '66097.53', '4566.74'], ['8.56422809829', '36.8113087607', '89327.88', '14050.14'], ['8.62268641471', '35.087834525', '20534.72', '11883.3'], ['4.83114713217', '17.9033416459', '5742.23', '11597.18'], ['10.2701848998', '38.2349306626', '15987.52', '23801.1'], ['12.5816945607', '41.9222384937', '13518.07', '22824.14'], ['16.0599706745', '50.8491202346', '17574.68', '18957.2'], ['11.8677385892', '36.282033195', '24357.22', '19832.94'], ['10.2945011338', '39.7768253968', '29611.32', '4258.14'], ['4.17606557377', '16.4770435274', '18571.65', '17116.11'], ['9.36189873418', '35.4246202532', '18712.28', '7499.47'], ['11.0917085427', '48.8443718593', '8458.2', '11367.4'], ['5.3244966443', '20.2525251678', '19089.74', '8041.09'], ['6.63090439276', '24.2994315245', '7305.46', '11966.94'], ['8.58392405063', '34.2229535865', '14796.7', '12707.72'], ['5.53106109325', '25.2890353698', '8200.55', '22130.31'], ['6.13912310287', '26.0607419899', '11412.54', '20817.32'], ['8.47737603306', '33.6023140496', '11228.97', '16786.98'], ['8.44393241167', '37.4071121352', '17232.45', '19203.82'], ['5.15196394076', '20.6980424984', '21340.78', '25302.92'], ['6.53706864564', '22.8882189239', '16617.85', '18650.96'], ['8.50044523598', '27.5077292965', '21711.71', '14626.29'], ['3.93154326923', '21.8116586538', '28128.95', '46323.73'], ['6.16368913858', '25.4285205993', '21803.2', '535381.86'], ['4.90444711538', '19.5683173077', '12517.29', '812011.78'], ['7.40241271087', '26.9353354257', '53988.92', '206247.57'], ['47.5032692308', '235.730677515', '555707.4', '6402.78'], ['55.7391800938', '268.869600245', '1082136.01', '100765.67'], ['11.8407803201', '56.4333884407', '192089.46', '20098.61'], ['7.00229357798', '26.4409174312', '5574.99', '68230.36'], ['8.75314206706', '45.2938472174', '80241.27', '596063.0'], ['3.14774130328', '15.5945516903', '27043.54', '87471.43'], ['7.1967787944', '27.2886517761', '61977.54', '431990.7'], ['76.2036918138', '367.225653291', '977772.62', '136717.57'], ['10.8043371086', '42.0311992005', '41905.18', '30008.81'], ['10.705327051', '45.8914772727', '87839.45', '19420.34'], ['51.8006862745', '255.153235294', '445058.32', '274752.6'], ['5.88277871731', '27.5122713672', '127495.18', '10315.35'], ['6.68640645161', '26.1030967742', '23874.67', '45252.42'], ['5.83335488041', '23.7416031028', '21535.87', '433832.28'], ['45.5560956385', '218.008349974', '276096.18', '74215.43'], ['5.17260575296', '21.5487817259', '8506.79', '78137.29'], ['10.118018018', '46.7007087087', '49163.01', '83915.72'], ['51.6755374204', '233.533188694', '434110.57', '372240.72'], ['2.79463149728', '11.9961176992', '73789.38', '148021.9'], ['7.61169779853', '38.8099733155', '88006.84', '31184.18'], ['15.6976512739', '105.035207006', '117958.96', '33324.36'], ['50.2758932156', '225.055138499', '407738.79', '32079.13']] NOTE: At first I had noted that an f.close() statement was needed at the end of this function. But it was rightly pointed out to me that this is a built in functionality for the with statement code block and is therefore not needed.","tags":"python","loc":"http://www.instantinate.com/python/load_dataset_with_csv_reader.html","title":"Load Dataset with CSV.reader"}]}